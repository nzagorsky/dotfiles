#!/usr/bin/env python
import os
import re
import sys

WMCTRL_LIST_COLUMNS = ['id',
                       'desktop',
                       'x', 'y',
                       'size_x', 'size_y',
                       'host',
                       'name']

if len(sys.argv) < 2:
    raise SystemExit('Need to provide direction')

DIRECTION = sys.argv[1].strip().lower()


def _diff(a, b):
    response = (a - b) / ((a + b) / 2) * 100
    return response or 1


def get_current_screen():
    screens = os.popen('wmctrl -d').read()
    current_screen = None
    for screen in screens.split('\n'):
        if '*' in screen:
            current_screen = screen[:1]
            break
    if not current_screen:
        raise Exception('No screen found')
    return current_screen


def get_current_window(return_name=False):
    if return_name:
        return os.popen('xdotool getwindowfocus getwindowname').read().strip()
    else:
        return os.popen('xdotool getwindowfocus').read().strip()


def get_windows():
    window_list = os.popen('wmctrl -Gl').read()
    windows = []
    for window in window_list.split('\n'):
        if len(window) > 5:
            window_data = re.split('\s+', window, 7)
            meta = dict(zip(WMCTRL_LIST_COLUMNS, window_data))
            meta['x'] = int(meta['x'])
            meta['y'] = int(meta['y'])
            windows.append(meta)
    return windows


def activate_window(window_id):
    os.system('xdotool windowactivate {}'.format(window_id))


def get_windows_on_current_desktop():
    current_screen = get_current_screen()
    current_window = get_current_window(return_name=True)
    windows = filter(lambda x: x and x['desktop'] == current_screen, get_windows())
    return list(windows), current_window


def _switch_left(window, window_list):
    """
    To inverse you have to use > in matching windows and reverse in closest_match
    """
    x, y = window['x'], window['y']
    window_to_select = None

    window_list = list(sorted(window_list, key=lambda z: z['x'], reverse=True))
    matching_windows = list(
        filter(
            lambda z: z['x'] <= x and window['id'] != z['id'],
            window_list
        )
    )

    if not matching_windows:
        print('Nothing on the right, using left')
        window_list.sort(key=lambda z: z['x'])
        window_to_select = window_list[-1]

    elif len(matching_windows) == 1:
        # Select only match.
        print('Found only one match')
        window_to_select = matching_windows[0]

    else:
        # Looking for closest windows
        print('Getting closest match on Y')

        # Should have max diff for X and min diff for Y to ensure moving in a row.
        # Give additional weight to X to ensure moving in this coordinates.
        closest_match = sorted(
            matching_windows,
            key=lambda z: (_diff(z['x'], x) * 100000) / _diff(z['y'], y),
        )
        for match in closest_match:
            print(match)
        print(window, x, y)
        window_to_select = list(closest_match)[0]

    activate_window(window_to_select['id'])


def _switch_right(window, window_list):
    x, y = window['x'], window['y']
    window_to_select = None

    window_list = list(sorted(window_list, key=lambda z: z['x'], reverse=True))
    matching_windows = list(
        filter(
            lambda z: z['x'] >= x and window['id'] != z['id'],
            window_list
        )
    )

    if not matching_windows:
        print('Nothing on the right, using left')
        window_list.sort(key=lambda z: z['x'])
        window_to_select = window_list[0]

    elif len(matching_windows) == 1:
        # Select only match.
        print('Found only one match')
        window_to_select = matching_windows[0]

    else:
        # Looking for closest windows
        print('Getting closest match on Y')

        # Should have max diff for X and min diff for Y to ensure moving in a row.
        # Give additional weight to X to ensure moving in this coordinates.
        closest_match = sorted(
            matching_windows,
            key=lambda z: (_diff(z['x'], x) * 100000) / _diff(z['y'], y),
        )
        for match in closest_match:
            print(match)
        print(window, x, y)
        window_to_select = list(closest_match)[0]

    activate_window(window_to_select['id'])


def _switch_down(window, window_list):
    x, y = window['x'], window['y']
    window_to_select = None

    window_list = list(sorted(window_list, key=lambda z: z['x'], reverse=True))
    matching_windows = list(
        filter(
            lambda z: z['y'] >= y and window['id'] != z['id'],
            window_list
        )
    )

    if not matching_windows:
        print('Nothing on the right, using left')
        window_list.sort(key=lambda z: z['y'])
        window_to_select = window_list[0]

    elif len(matching_windows) == 1:
        # Select only match.
        print('Found only one match')
        window_to_select = matching_windows[0]

    else:
        # Looking for closest windows
        print('Getting closest match on Y')

        # Should have max diff for X and min diff for Y to ensure moving in a row.
        # Give additional weight to X to ensure moving in this coordinates.
        closest_match = sorted(
            matching_windows,
            key=lambda z: (_diff(z['y'], y) * 100000) / _diff(z['x'], x),
        )
        for match in closest_match:
            print(match)
        print(window, x, y)
        window_to_select = list(closest_match)[0]

    activate_window(window_to_select['id'])


def _switch_up(window, window_list):
    x, y = window['x'], window['y']
    window_to_select = None

    window_list = list(sorted(window_list, key=lambda z: z['x'], reverse=True))
    matching_windows = list(
        filter(
            lambda z: z['y'] <= y and window['id'] != z['id'],
            window_list
        )
    )

    if not matching_windows:
        print('Nothing on the right, using left')
        window_list.sort(key=lambda z: z['y'])
        window_to_select = window_list[0]

    elif len(matching_windows) == 1:
        # Select only match.
        print('Found only one match')
        window_to_select = matching_windows[0]

    else:
        # Looking for closest windows
        print('Getting closest match on Y')

        # Should have max diff for X and min diff for Y to ensure moving in a row.
        # Give additional weight to X to ensure moving in this coordinates.
        closest_match = sorted(
            matching_windows,
            key=lambda z: (_diff(z['y'], y) * 100000) / _diff(z['x'], x),
        )
        for match in closest_match:
            print(match)
        print(window, x, y)
        window_to_select = list(closest_match)[0]

    activate_window(window_to_select['id'])


def switch_window():
    SWITCH_MAP = {
        'up': _switch_up,
        'down': _switch_down,
        'left': _switch_left,
        'right': _switch_right,
    }

    windows, current_window_name = get_windows_on_current_desktop()

    for window in windows:
        if current_window_name == window['name']:
            handler = SWITCH_MAP.get(DIRECTION)
            handler(window, windows)


if __name__ == '__main__':
    switch_window()
